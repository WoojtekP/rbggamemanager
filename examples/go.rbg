#game = "Go"
// notes:
// - area scoring
// - no ko rule

#boardLine = [empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty, empty]
#board = boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine boardLine 

#players = black, white

#pieces = empty, blackStone, whiteStone, tocapture, dame

#variables = blackpass, whitepass

#anySquare = (((1,0)^*+(-1,0)^*)((0,1)^*+(0,-1)^*))

#hasNeighbor(neighbor) =
    ((1,0)(neighbor) + (0,1)(neighbor) + (-1,0)(neighbor) + (0,-1)(neighbor))

#blockHasNeighbor(block; neighbor) =
    (block) hasNeighbor(block)^* hasNeighbor(neighbor)

#neighborBlockHasNoLiberty(x; y; color) = 
    ( (!(x,y)(color)) and not (!(x,y)blockHasNeighbor(color; empty)) )
     
#legalMove(color; opponentColor) = 
    (
      anySquare
      (empty)
      [color]
      (?
          // Stawiamy na puste pole, które należy do bloku posiadającego oddech
        (!blockHasNeighbor(color; empty))
        // Stawiamy na puste pole które ma za sąsiada blok przeciwnika nie mający oddechu
        or neighborBlockHasNoLiberty( 1; 0; opponentColor)
        or neighborBlockHasNoLiberty(-1; 0; opponentColor)
        or neighborBlockHasNoLiberty(0;  1; opponentColor)
        or neighborBlockHasNoLiberty(0; -1; opponentColor)
      )
    )

// Jeśli sąsiedni blok powinien zostać usunięty, to zaznaczamy jeden jego kamień na 'tocapture'
#markToCapture(opponentColor) = 
    (
      (
          (? neighborBlockHasNoLiberty(1; 0; opponentColor) ) (1,0)[tocapture]->(-1,0)
        + (? not neighborBlockHasNoLiberty(1; 0; opponentColor) ) 
      )
      (
          (? neighborBlockHasNoLiberty(-1; 0; opponentColor) ) (-1,0)[tocapture]->(1,0)
        + (? not neighborBlockHasNoLiberty(-1; 0; opponentColor) ) 
      )
      (
          (? neighborBlockHasNoLiberty(0; 1; opponentColor) ) (0,1)[tocapture]->(0,-1)
        + (? not neighborBlockHasNoLiberty(0; 1; opponentColor) ) 
      )
      (
          (? neighborBlockHasNoLiberty(0; -1; opponentColor) ) (0,-1)[tocapture]->(0,1)
        + (? not neighborBlockHasNoLiberty(0; -1; opponentColor) ) 
      )
    )
      
// Zaznaczamy wszystkie kamienie odpowiedniego koloru sąsiadujące z 'tocapture' jako 'tocapture'
#floodfillCaptures(opponentColor) = 
    (
      (
        anySquare
        (tocapture)
        hasNeighbor(opponentColor)
        [tocapture]->
      )^*
      (? not (! anySquare (tocapture) hasNeighbor(opponentColor)) )
    )

// Usuwamy z planszy wszystkie 'tocapture'
#clearCaptures = 
    (
      (
        anySquare
        (tocapture)
        [empty]->
      )^*
      (? not (! anySquare (tocapture)) )
    )
    
// dopóki na planszy są puste pola (bloki) to zapełniamy je neutralnymi jeśli blok jest otoczony kamieniami obu graczy (lub dame)
// lub zapełniamy kamieniami gracza który go otacza jednoznacznie
// gdy pustych pól już nie ma score każdego z graczy to liczba jego kamieni
// (dla uproszczenia, zamiast wypełniać floodfillem całe bloki, możemy to robić wygodniej kamień po kamieniu)
//
// https://www.reddit.com/r/baduk/comments/13dt8t/help_writing_a_scoring_algorithm_for_a_go_game/?st=ja5l3bw8&sh=91192330
// https://senseis.xmp.net/?Scoring
#countPoints = 
    (
      (
        anySquare 
        (empty)->
        (
            (? ( (!blockHasNeighbor(empty; blackStone)) and (!blockHasNeighbor(empty; whiteStone))) or (!blockHasNeighbor(empty; dame)) )
            [dame]->
          + (? (!blockHasNeighbor(empty; blackStone)) and not (!blockHasNeighbor(empty; whiteStone)) and not (!blockHasNeighbor(empty; dame)) )
            [blackStone]->
          + (? not (!blockHasNeighbor(empty; blackStone)) and (!blockHasNeighbor(empty; whiteStone)) and not (!blockHasNeighbor(empty; dame)) )
            [whiteStone]->
        )
      )^*  
      (? not (! anySquare (empty)) )
      [$white=$whiteStone]
      [$black=$blackStone]
    )

#placeStoneOrPass(me; opponent) =
    (
        [$me~pass=0] legalMove(me~Stone; opponent~Stone) -> markToCapture(opponent~Stone) -> floodfillCaptures(opponent~Stone) ->
        clearCaptures
      + [$me~pass=1]
    )


// koniec gry jeśli obu graczy spasowało pod rząd
#endgameCheck = 
    (
        (? ($blackpass==0 or $whitepass==0) and ($turn < 722))
      + (? ($blackpass==1 and $whitepass==1) or ($turn >= 722))
        countPoints
        ->()
    )
 
#rules = 
    (
      placeStoneOrPass(black; white) 
      endgameCheck
      ->white
      placeStoneOrPass(white; black) 
      endgameCheck
      ->black
    )^*
    
#finalizer = ()
